var documenterSearchIndex = {"docs":
[{"location":"distributions.html#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions.html","page":"Distributions","title":"Distributions","text":"there are no docstrings in this folder","category":"page"},{"location":"distributions.html","page":"Distributions","title":"Distributions","text":"Modules = [MCPhylo]\r\nPages   = [\"distributions/constructors.jl\", \"distributionstruct.jl\", \"extensions.jl\", \"pdmatdistribution.jl\", \"pdmats2.jl\", \"Phylodist.jl\", \"transformdistribution.jl\", \"TreeConstraints.jl\"]\r\nFilter = ","category":"page"},{"location":"Sampler.html#Sampler","page":"Sampler","title":"Sampler","text":"","category":"section"},{"location":"Sampler.html","page":"Sampler","title":"Sampler","text":"there are no docstrings in this folder","category":"page"},{"location":"Sampler.html","page":"Sampler","title":"Sampler","text":"Modules = [MCPhylo]\r\nPages   = [\"Sampler/SamplerFunctions.jl\", \"PNUTS.jl\", \"ProbPathHMC.jl\"]\r\nFilter = ","category":"page"},{"location":"Utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Functions found in all files of Utils folder, ordered according to file of origin.","category":"page"},{"location":"Utils.html#utils.jl","page":"Utils","title":"utils.jl","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"utils.jl\"]","category":"page"},{"location":"Utils.html#Main.MCPhylo.lcp-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractString","page":"Utils","title":"Main.MCPhylo.lcp","text":"lcp(str1::T, str2::T)::T where T <: AbstractString\n\nGet the longest common prefix.\n\n\n\n\n\n","category":"method"},{"location":"Utils.html#FileIO.jl","page":"Utils","title":"FileIO.jl","text":"","category":"section"},{"location":"Utils.html","page":"Utils","title":"Utils","text":"Modules = [MCPhylo]\r\nPages   = [\"Utils/FileIO.jl\"]","category":"page"},{"location":"Utils.html#Main.MCPhylo.to_file-Tuple{Main.MCPhylo.ModelChains,AbstractString}","page":"Utils","title":"Main.MCPhylo.to_file","text":"to_file(model::ModelChains, outpath::AbstractString)\n\nThis function writes the results of the MCMC runs into files. The destination of the files is specified using outpath. It will create a files for each chain. A params_x.log file storing each parameter sample. In this case x specifies the index of the chain. The file is compatible with MCMC analysis tools like Tracer (http://tree.bio.ed.ac.uk/software/tracer/). If in addition trees are sampled, they are stored in newick format in a file called trees_x.nwk, where x again specifies the index of the respective chain.\n\n\n\n\n\n","category":"method"},{"location":"output.html#output","page":"Output","title":"output","text":"","category":"section"},{"location":"output.html","page":"Output","title":"Output","text":"there are no docstrings in this folder","category":"page"},{"location":"output.html","page":"Output","title":"Output","text":"Modules = [MCPhylo]\r\nPages   = [\"output/chains.jl\", \"chainsummary.jl\", \"discretediag.jl\", \"fileio.jl\", \"gelmandiag.jl\", \"gewekediag.jl\", \"heideldiag.jl\", \"mcse.jl\", \"modelchains.jl\", \"modelstats.jl\", \"plot.jl\", \"rafterydiag.jl\", \"stats.jl\"]\r\nFilter = ","category":"page"},{"location":"toc.html#MCPhylo-Documentation","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"","category":"section"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"All functions provided by the MCPhylo package are detailed below, organized according to the file they are sourced from.","category":"page"},{"location":"toc.html#Here's-an-example-list","page":"MCPhylo Documentation","title":"Here's an example list","text":"","category":"section"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"one\ntwo\nthree\nfour\nLaTeX syntax works too\nwe can even make links to google.","category":"page"},{"location":"toc.html#Here's-an-example-inset","page":"MCPhylo Documentation","title":"Here's an example inset","text":"","category":"section"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"inset text\r\nthis is all in a box\r\ntext in a box","category":"page"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"note: Note\nThis is the content of the note.","category":"page"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"warning: I can write anything here apparently!\nAnd this is another one.these can be multi-line","category":"page"},{"location":"toc.html","page":"MCPhylo Documentation","title":"MCPhylo Documentation","text":"Pages = [\"Tree.md\", \"Likelihood.md\", \"Parser.md\", \"distributions.md\", \"model.md\", \"output.md\", \"Sampler.md\", \"samplers.md\", \"Utils.md\"]","category":"page"},{"location":"intro.html#MCPhylo","page":"Introduction","title":"MCPhylo","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package does phylogenetic computations in Julia. It is an extension of the Mamba package which does Markov Chain Monte Carlo (MCMC) sampling for Bayesian analysis. (https://mambajl.readthedocs.io/en/latest/) MCPhylo extends Mamba by a tree module to perform phylogenetic computations.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"which currently supports the output of newick strings for tree structures. The goal is to facilitate phylogenetic computations in computational historical linguistics. To facilitate the inference of phylogenetic trees, Probabilistic Path Hamiltonian Dynamics (https://arxiv.org/pdf/1702.07814.pdf) are implemented.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package is currently under heavy development.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package needs at least Julia 1.3.1. This package is not backwards compatible!","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This module is build on a forked instance of Mamba 0.12.0","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Note This package uses multithreading. (https://docs.julialang.org/en/v1/base/multi-threading/)","category":"page"},{"location":"intro.html#General-Information","page":"Introduction","title":"General Information","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"In order to use the current version of the package clone the repo and place it into your current working directory.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"include(\"./src/MCPhylo.jl\")\r\nusing .MCPhylo","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Installation of the package may also work.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"using Pkg\r\nPkg.add(\"https://github.com/erathorn/JuliaTree\")","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"The setup of a model is as in the original Mamba package.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Nexus and CSV files with binarized cognate data are supported.","category":"page"},{"location":"intro.html#New-Functions","page":"Introduction","title":"New Functions","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"The standard mcmc function from Mamba takes an extra Boolean argument trees indicating if the sampled trees should be stored. If set to true the trees will be stored. The default is false.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"You can flush the model parameters and the sampled trees to a file, using the to_file function. It takes as a first argument an MCMC object and second a path to a folder where the results should be stored. This file can be read by the Tracer software (https://github.com/beast-dev/tracer/). Additionally, if trees are stored it will create a file with newick strings of these trees.","category":"page"},{"location":"intro.html#New-and-Adjusted-Samplers","page":"Introduction","title":"New & Adjusted Samplers","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"PNUTS is a sampler which does Phylogenetic No-U-Turn sampling (Wahle (forthcomming)). It samples tree stochastic nodes.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"RWM Random walk metroplis hastings sampling can work with trees now. For numerical nodes the sampler and the function signature is as in the original Mamba package. For tree structures the signature is slightly different: RWM(:tree, :all) or RWM(:tree, [:NNI, :Swing]) The first variant uses all available tree manipulation moves (see Tree Manipulation), the second variant only makes use of a user defined subset of these moves. Ladderization of the tree is not an eligible tree manipulation move","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"NUTS can take the argument dtype=:Zygote to use Zygote for the calculation of the gradient. The default is finite differencing.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Slice can also sample trees. It does a slice sampling operation on the branch lengths of the tree.","category":"page"},{"location":"intro.html#Tree-Functionalities","page":"Introduction","title":"Tree Functionalities","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"For the available tree functionalities see: Tree Functionalities, and for exact documentation of the functions involved, see the Tree Functionality page linked along the left-hand side of the page.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Pages = [\"Tree.md\", \"Likelihood.md\", \"Parser.md\", \"distributions.md\", \"model.md\", \"output.md\", \"Sampler.md\", \"samplers.md\", \"Substitution.md\", \"Utils.md\"]","category":"page"},{"location":"Links.html#Links","page":"Links","title":"Links","text":"","category":"section"},{"location":"Links.html","page":"Links","title":"Links","text":"Below we've provided links to relevant Jupyter Notebooks and publications. More will be added as they come. ","category":"page"},{"location":"Links.html#Notebooks","page":"Links","title":"Notebooks","text":"","category":"section"},{"location":"Links.html#[Markov-Chain-Monte-Carlo-for-Tree-structures](https://github.com/erathorn/Julia_Tree/blob/master/notebook/MCPhylo.ipynb)","page":"Links","title":"Markov Chain Monte Carlo for Tree structures","text":"","category":"section"},{"location":"Links.html","page":"Links","title":"Links","text":"A software package to calculate statistic problems including (phylogenetic) tree structures","category":"page"},{"location":"Links.html#Papers,-References","page":"Links","title":"Papers, References","text":"","category":"section"},{"location":"Links.html#[Markov-Chain-Monte-Carlo-in-Julia](https://mambajl.readthedocs.io/en/latest/)","page":"Links","title":"Markov Chain Monte Carlo in Julia","text":"","category":"section"},{"location":"Links.html#[Probabilistic-Path-Hamiltonian-Dynamics](https://arxiv.org/pdf/1702.07814.pdf)","page":"Links","title":"Probabilistic Path Hamiltonian Dynamics","text":"","category":"section"},{"location":"Tree.html#Tree-Functionality","page":"Tree Functionality","title":"Tree Functionality","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Functions found in all files of Tree folder, ordered according to file of origin.","category":"page"},{"location":"Tree.html#Converter.jl","page":"Tree Functionality","title":"Converter.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.from_df\r\nMain.MCPhylo.newick(::T) where T<:Main.MCPhylo.GeneralNode\r\nMain.MCPhylo.to_covariance\r\nMain.MCPhylo.to_covariance_ultra\r\nMain.MCPhylo.to_df\r\nMain.MCPhylo.to_distance_matrix","category":"page"},{"location":"Tree.html#Main.MCPhylo.from_df","page":"Tree Functionality","title":"Main.MCPhylo.from_df","text":"from_df(df::DataFrame)::Node\n\nThis function takes a DataFrame and turns it into a tree. It assumes a rooted binary tree is stored in the matrix. No checks are performed.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.newick","text":"newick(node::Node)::String\n\nCreates a newick represnetation of the tree.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.to_covariance","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance","text":"to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N<:GeneralNode,T<: Real}\n\nCalcualte the variance-covariance matrix from tree. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.to_covariance_ultra","page":"Tree Functionality","title":"Main.MCPhylo.to_covariance_ultra","text":"to_covariance_ultra(tree::Node)::Array{T,2} where T<: Real\n\nGet the covariance matrix of the ultrametric version of tree with height 1.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.to_df","page":"Tree Functionality","title":"Main.MCPhylo.to_df","text":"to_df(root::Node)::DataFrame\n\nThis function returns a matrix representation of the tree structure. The matirx is returned as a DataFrame so that the names of the columns are the names of the tips in the tree. The entry df[i,j] is the length of the edge connecting node i with node j.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.to_distance_matrix","page":"Tree Functionality","title":"Main.MCPhylo.to_distance_matrix","text":"to_distance_matrix(tree::T)::Array{Float64,2} where T <:GeneralNode\n\nCalculate the distance matrix over the set of leaves.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Node_Type.jl","page":"Tree Functionality","title":"Node_Type.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Node_Type.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Tree_Basics.jl","page":"Tree Functionality","title":"Tree_Basics.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"This file is a bit larger, and so will be broken into (hopefully coherent) subgroups, listed here:","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Tree Editing","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Return Functions","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Metavariable Functions","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Variable Functions","category":"page"},{"location":"Tree.html#Tree-Editing","page":"Tree Functionality","title":"Tree Editing","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"These functions edit the makeup of an existing tree.","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.add_child!\r\nMain.MCPhylo.delete_node!\r\nMain.MCPhylo.insert_node!\r\nMain.MCPhylo.remove_child!\r\nMain.MCPhylo.create_tree_from_leaves\r\n","category":"page"},{"location":"Tree.html#Main.MCPhylo.add_child!","page":"Tree Functionality","title":"Main.MCPhylo.add_child!","text":"add_child!(mother_node::Node, child::Node, child_position::Union{Int64, Missing}=missing)\n\nThis function adds a child to the mother node. The arity of the mother node is increased by 1 and the root status of the child is set to False.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.delete_node!","page":"Tree Functionality","title":"Main.MCPhylo.delete_node!","text":"delete_node!(node::Node)::Nothing\n\nThis functions deletes node from a tree and assigns all its children to its mother node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.insert_node!","page":"Tree Functionality","title":"Main.MCPhylo.insert_node!","text":"insert_node!(mother::Node, children::Vector{T})::T where T<:AbstractNode\n\nThis function inserts a node into a tree after a mother node and gains a subset of the mother's children as its children. Returns the inserted node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.remove_child!","page":"Tree Functionality","title":"Main.MCPhylo.remove_child!","text":"remove_child!(mother_node::Node, left::Bool)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node. The removed node is returned. An input of \"True\" removes the left child, while \"False\" removes the right child.\n\n\n\n\n\nremove_child!(mother_node::Node, child::Node)::Node\n\nThis function removes a child from the list of nodes which are daughters of this node. The removed node is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.create_tree_from_leaves","page":"Tree Functionality","title":"Main.MCPhylo.create_tree_from_leaves","text":"create_tree_from_leaves(leaf_nodes::Vector{T})::Node\n\nThis function creates a  random binary tree from a list of leaf nodes. The root node as access point for the tree is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Return-Functions","page":"Tree Functionality","title":"Return Functions","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"These functions return the values of a given variable of a tree.","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.get_mother\r\nMain.MCPhylo.get_sister\r\nMain.MCPhylo.node_height\r\nMain.MCPhylo.random_node\r\n\r\n","category":"page"},{"location":"Tree.html#Main.MCPhylo.get_mother","page":"Tree Functionality","title":"Main.MCPhylo.get_mother","text":"function get_mother(node::T)::T  where T<:GeneralNode\n\nThis function gets the mother of node. It does so by looking for the respective binary representation of the mother node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_sister","page":"Tree Functionality","title":"Main.MCPhylo.get_sister","text":"get_sister(node::T)::T  where T<:GeneralNode\n\nThis function gets the sister of node. It does so by looking for the respective binary representation of the sister.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.node_height","page":"Tree Functionality","title":"Main.MCPhylo.node_height","text":"node_height(root::T, mv::Float64)::Float64  where T<:GeneralNode\n\nCalculate the height of a node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.random_node","page":"Tree Functionality","title":"Main.MCPhylo.random_node","text":"function random_node(root::T)::T  where T<:GeneralNode\n\nThis function returns a random node from the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Metavariable-Functions","page":"Tree Functionality","title":"Metavariable Functions","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"These functions calculate metavariables for a given tree.","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.tree_length(::T) where T<:Main.MCPhylo.GeneralNode\r\nMain.MCPhylo.tree_height\r\nMain.MCPhylo.get_branchlength_vector\r\nMain.MCPhylo.get_sum_seperate_length!\r\nMain.MCPhylo.check_binary\r\nMain.MCPhylo.path_length","category":"page"},{"location":"Tree.html#Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.tree_length","text":"tree_length(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree length.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.tree_height","page":"Tree Functionality","title":"Main.MCPhylo.tree_height","text":"tree_height(root::T)::Float64  where T<:GeneralNode\n\nThis function calculates the tree height.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(root::N)::Vector{T}  where {N <:GeneralNode, T<:Real}\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nget_branchlength_vector(t::TreeStochastic)\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nget_branchlength_vector(root::N, out_vec::Vector{T}) where {N<:GeneralNode, T<:Real}\n\nDo post order traversal to retrieve a vector of branch lengths.\n\n\n\n\n\nget_branchlength_vector(post_order::Vector{Node})::Vector{Float64}\n\nReturn a vector of branch lengths.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.get_sum_seperate_length!","page":"Tree Functionality","title":"Main.MCPhylo.get_sum_seperate_length!","text":"get_sum_seperate_length!(root::T)::Vector{Float64}  where T<:GeneralNode\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\nget_sum_seperate_length!(post_order::Vector{T})::Vector{Float64}  where T<:GeneralNode\n\nThis function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.check_binary","page":"Tree Functionality","title":"Main.MCPhylo.check_binary","text":"check_binary(root::Node)::Bool\n\nchecks to see if given tree is binary; returns true if properly formatted and false otherwise\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.path_length","page":"Tree Functionality","title":"Main.MCPhylo.path_length","text":"path_length(ancestor::T, descendant::T)::Float64  where T<:GeneralNode\n\nNote: The function assumes there is an ancestral relationship between the two nodes.\n\nThis function calculates the length of the path separating the ancestor from the offspring node. The function follows the path specified through the binary description of the node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Variable-Functions","page":"Tree Functionality","title":"Variable Functions","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"These Functions calculate/edit variables for a given tree.","category":"page"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.force_ultrametric!\r\nMain.MCPhylo.number_nodes!\r\nMain.MCPhylo.set_branchlength_vector!\r\nMain.MCPhylo.set_binary!","category":"page"},{"location":"Tree.html#Main.MCPhylo.force_ultrametric!","page":"Tree Functionality","title":"Main.MCPhylo.force_ultrametric!","text":"force_ultrametric!(root::T) where T<:GeneralNode\n\nForce an ultrametric version of the tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.number_nodes!","page":"Tree Functionality","title":"Main.MCPhylo.number_nodes!","text":"number_nodes!(root::T)::Nothing  where T<:GeneralNode\n\nThis function assigns a unique, sequential number to each node.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.set_branchlength_vector!","page":"Tree Functionality","title":"Main.MCPhylo.set_branchlength_vector!","text":"set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T <: Real\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nset_branchlength_vector!(t::TreeStochastic, blenvec::ArrayStochastic)\n\nGet the vector of branch lengths of the tree.\n\n\n\n\n\nset_branchlength_vector!(root::N, blenvec::Array{T}) where {N<:GeneralNode, T<:Real}\n\nThis function sets the branch lengths of a tree to the values specified in blenvec.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.set_binary!","page":"Tree Functionality","title":"Main.MCPhylo.set_binary!","text":"set_binary!(root::Node)\n\nAssign a binary representation to each node, which specifies the path from the root to this node via the binary representation of the node. A left turn is a 1 in binary and a right turn a 0.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Clustering.jl","page":"Tree Functionality","title":"Tree_Clustering.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.neighbor_joining\r\nMain.MCPhylo.upgma","category":"page"},{"location":"Tree.html#Main.MCPhylo.neighbor_joining","page":"Tree Functionality","title":"Main.MCPhylo.neighbor_joining","text":"neighbor_joining(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\nneighbor_joining(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.upgma","page":"Tree Functionality","title":"Main.MCPhylo.upgma","text":"upgma(dm::Array{Float64,2}, Array{String,1})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\nupgma(dm::Array{Float64,2})\n\nThis function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Consensus.jl","page":"Tree Functionality","title":"Tree_Consensus.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Consensus.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.find_common_clusters","text":"find_common_clusters(ref_tree, tree:T)\n    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}\n\nUse Day's algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.majority_consensus_tree","text":"majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)::T where T<:AbstractNode\n\nConstruct the majority rule consensus tree from a set of trees. By default includes cluster that occur in over 50% of the trees.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.max_leaf_rank","text":"max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T<:AbstractNode\n\nRecursive helper function to find the highest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.merge_trees!","text":"merge_trees!(ref_tree::T, tree::T)::Tuple{T, Vector{T}} where T<:AbstractNode\n\nMerge two compatible trees, i.e. inserts all cluster of the first tree, which aren't already in the second tree, into the secon tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.min_leaf_rank","text":"min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)\n    ::Int64 where T <: AbstractNode\n\nRecursive helper function to find the lowest ranked leaf descendant of a node\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.one_way_compatible","text":"one_way_compatible(ref_tree::T, tree::T)::T where T<:AbstractNode\n\nTakes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.order_tree!","text":"order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())\n    ::Vector{T} where T<:AbstractNode\n\nHelper function to order a tree based on cluster indeces and return the leaves of the ordered tree\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_left","text":"x_left(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\nHelper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.x_right","text":"x_right(node::T)::Tuple{T,Vector{T}} where T<:AbstractNode\n\nHelper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Distance.jl","page":"Tree Functionality","title":"Tree_Distance.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Distance.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.BHV_bounds","text":"BHV_bounds(tree1::T, tree2::T)::Tuple{Float64, Float64} where T <:GeneralNode\n\nThis function calculates the lower and upper bounds of the geodesic in the Billera-Holmes-Vogtman space.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.RF","text":"RF(tree1::T, tree2::T)::Int64 where T <:GeneralNode\n\nCalculate the Robinson-Foulds distance between the two trees. In its current form the function assumes the trees have identical leave sets.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_bipartitions","text":"get_bipartitions(tree::T)::Vector{Tuple} where T <:GeneralNode\n\nGet a vector of all bipartions of tree. The resulting vector contains Tuples of sets representing the bipartions.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Ladderizing.jl","page":"Tree Functionality","title":"Tree_Ladderizing.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Ladderizing.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree!","text":"ladderize_tree!(root::T, ascending::Bool=true)::Nothing where T<:AbstractNode)\n\nThis function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Main.MCPhylo.AbstractNode","page":"Tree Functionality","title":"Main.MCPhylo.ladderize_tree","text":"ladderize_tree(root::T, ascending::Bool=true)::T where T<:AbstractNode)\n\nThis function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_Legacy.jl","page":"Tree Functionality","title":"Tree_Legacy.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Modules = [MCPhylo]\r\nPages   = [\"Tree_Legacy.jl\"]\r\nFilter =","category":"page"},{"location":"Tree.html#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T<:Main.MCPhylo.GeneralNode","page":"Tree Functionality","title":"Main.MCPhylo.get_branchlength_vector","text":"get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}\n\nReturn a vector of branch lengths.\n\n\n\n\n\n","category":"method"},{"location":"Tree.html#Tree_moves.jl","page":"Tree Functionality","title":"Tree_moves.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.NNI!\r\nMain.MCPhylo.NNI\r\nMain.MCPhylo.change_edge_length!\r\nMain.MCPhylo.move!\r\nMain.MCPhylo.perform_spr\r\nMain.MCPhylo.randomize!\r\nMain.MCPhylo.risky_SPR!\r\nMain.MCPhylo.risky_SPR\r\nMain.MCPhylo.slide\r\nMain.MCPhylo.slide!\r\nMain.MCPhylo.swing!\r\nMain.MCPhylo.swing","category":"page"},{"location":"Tree.html#Main.MCPhylo.NNI!","page":"Tree Functionality","title":"Main.MCPhylo.NNI!","text":"NNI(root::T, target::T, lor::Bool)::Int64   where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The parameter target specifies the node which performs the interchange move using the left or right child of the target node. If the left child should be used lor=true. The function returns 1 if the move was successful and 0 else.\n\n\n\n\n\nNNI!(root::T, target::Int64)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node. The function returns 1 if the move was successful and 0 else.\n\n\n\n\n\nNNI!(root::T)::Int64  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root. The target is identified by the number of the target node. The function returns 1 if the move was successful and 0 else.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.NNI","page":"Tree Functionality","title":"Main.MCPhylo.NNI","text":"NNI(root::T)::T  where T<:GeneralNode\n\nThis function does a nearest neighbour interchange (NNI) move on the tree specified by root and returns a mutated copy while leaving the original tree intact.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.change_edge_length!","page":"Tree Functionality","title":"Main.MCPhylo.change_edge_length!","text":"change_edge_length!(root::T) where T <:GeneralNode\n\nPick a random node and increase or decrease its length randomly.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.move!","page":"Tree Functionality","title":"Main.MCPhylo.move!","text":"move!(node1::Node, node2::Node, proportion::Float64)\n\nChange the incoming length of node1 and node2 while keeping their combined length constant.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.perform_spr","page":"Tree Functionality","title":"Main.MCPhylo.perform_spr","text":"perform_spr(root::Node)\n\nperforms SPR on binary tree\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.randomize!","page":"Tree Functionality","title":"Main.MCPhylo.randomize!","text":"randomize!(root::Node, num::Int64=100)::nothing\n\nThis function randomizes the tree topology by performing a number of nearest neighbour interchange (NNI) moves. The number of NNI moves is specified in the parameter num.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.risky_SPR!","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR!","text":"    risky_SPR!(root::Node)::AbstractNode\nPerforms SPR on tree in place. Takes reference to root of tree\nReturns reference to root of altered tree. Does not check for correct formatting of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.risky_SPR","page":"Tree Functionality","title":"Main.MCPhylo.risky_SPR","text":"    risky_SPR(root::Node)::AbstractNode\nPerforms SPR on tree in place. Takes reference to root of tree\nReturns copy of root of altered tree. Does not check for correct formatting of tree.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.slide","page":"Tree Functionality","title":"Main.MCPhylo.slide","text":"slide(root::T)::T where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters. The new tree is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.slide!","page":"Tree Functionality","title":"Main.MCPhylo.slide!","text":"slide!(root::T) where T<:GeneralNode\n\nThis functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.swing!","page":"Tree Functionality","title":"Main.MCPhylo.swing!","text":"swing!(root::T) where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.swing","page":"Tree Functionality","title":"Main.MCPhylo.swing","text":"swing(root::T)::T where T<:GeneralNode\n\nThis function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children. The new tree is returned.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Pruning.jl","page":"Tree Functionality","title":"Tree_Pruning.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.prune_tree!\r\nMain.MCPhylo.prune_tree","category":"page"},{"location":"Tree.html#Main.MCPhylo.prune_tree!","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree!","text":"prune_tree!(root::T, node_names::Vector{String})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree\n\n\n\n\n\nprune_tree!(root::T, node_names::Vector{T})::Nothing where T<:AbstractNode\n\nIn-place version of prune_tree\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.prune_tree","page":"Tree Functionality","title":"Main.MCPhylo.prune_tree","text":"prune_tree(root::T, node_names::Vector{String})::T where T<:AbstractNode\n\nThis function returns a copy of a tree with specific nodes including their descendants removed\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Search.jl","page":"Tree Functionality","title":"Tree_Search.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.find_binary\r\nMain.MCPhylo.find_num\r\nMain.MCPhylo.find_root","category":"page"},{"location":"Tree.html#Main.MCPhylo.find_binary","page":"Tree Functionality","title":"Main.MCPhylo.find_binary","text":"find_binary(root::T, bin::String)::T where T<:GeneralNode\n\nFind a node by its binary representation. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure wheter the node is in the tree at all.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.find_num","page":"Tree Functionality","title":"Main.MCPhylo.find_num","text":"find_num(root::T, num::Int64)  where T<:GeneralNode\n\nFind a node by its number. The function assumes that the node is present in the tree.\n\nDo not use this function if you are unsure wheter the node is in the tree at all.\n\n\n\n\n\nfind_num(root::T, num::Int64, rn::Vector{T})::Bool  where T<:GeneralNode\n\nDo a post order traversal to find the node corresponding to the num.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.find_root","page":"Tree Functionality","title":"Main.MCPhylo.find_root","text":"find_root(node::Node)::Node\n\nTakes a node in a tree and finds the root of that tree\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Tree_Traversal.jl","page":"Tree Functionality","title":"Tree_Traversal.jl","text":"","category":"section"},{"location":"Tree.html","page":"Tree Functionality","title":"Tree Functionality","text":"Main.MCPhylo.get_leaves\r\nMain.MCPhylo.level_order\r\nMain.MCPhylo.level_traverse\r\nMain.MCPhylo.post_order\r\nMain.MCPhylo.pre_order","category":"page"},{"location":"Tree.html#Main.MCPhylo.get_leaves","page":"Tree Functionality","title":"Main.MCPhylo.get_leaves","text":"post_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a post order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the post order traversal.\n\n\n\n\n\npost_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does post order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.level_order","page":"Tree Functionality","title":"Main.MCPhylo.level_order","text":"level_order(node::T)::Array{T} where T<:GeneralNode\n\nThis function does level order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.level_traverse","page":"Tree Functionality","title":"Main.MCPhylo.level_traverse","text":"level_traverse(node::T, level::Int64, stack::Array{T})::Bool where T <:GeneralNode\n\nThis function traverses a level of the tree specified through node. The level is specified via the level argument and the nodes visited are stored in the stack. This function is intended as the internal worker for the level_order function.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.post_order","page":"Tree Functionality","title":"Main.MCPhylo.post_order","text":"post_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a post order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the post order traversal.\n\n\n\n\n\npost_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does post order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"function"},{"location":"Tree.html#Main.MCPhylo.pre_order","page":"Tree Functionality","title":"Main.MCPhylo.pre_order","text":"pre_order(root::T, traversal::Vector{T})::Vector{T} where T<:GeneralNode\n\nThis function performs a pre order traversal through the tree. It is assumed that root is the root of the tree. Thus, if root is not the root, the subtree defined by the root root is used for the pre order traversal.\n\n\n\n\n\npre_order(root::T)::Vector{T} where T<:GeneralNode\n\nThis function does pre order traversal. Only the root node needs to be supplied.\n\n\n\n\n\n","category":"function"},{"location":"model.html#model","page":"Model","title":"model","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"there are no docstrings in this folder","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"Modules = [MCPhylo]\r\nPages   = [\"model/dependent.jl\", \"dependent_tree.jl\", \"graph.jl\", \"initialization.jl\", \"mcmc.jl\", \"model.jl\", \"simulation.jl\"]\r\nFilter = ","category":"page"},{"location":"Likelihood.html#Likelihood","page":"Likelihood","title":"Likelihood","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"Functions found in all files of Likelihood folder, ordered according to file of origin.","category":"page"},{"location":"Likelihood.html#LikelihoodCalculator_Node.jl","page":"Likelihood","title":"LikelihoodCalculator_Node.jl","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"Modules = [MCPhylo]\r\nPages   = [\"Likelihood/LikelihoodCalculator_Node.jl\"]\r\nFilter = ","category":"page"},{"location":"Likelihood.html#Main.MCPhylo.FelsensteinFunction-Union{Tuple{N}, Tuple{T}, Tuple{Array{N,1},T,Array{Float64,1},Array{Float64,3},Int64,Array{Float64,1}}} where N<:Main.MCPhylo.GeneralNode where T<:Real","page":"Likelihood","title":"Main.MCPhylo.FelsensteinFunction","text":"FelsensteinFunction(treepostorder::Vector{N}, pi::T, rates::Vector{Float64}, data::Array{Float64,3}, n_c::Int64, blv::Vector{Float64}) where {T<:Real, N<:GeneralNode}\n\nThis function calculates the log-likelihood of an evolutiuonary model using the Felsensteins pruning algorithm.\n\nThe function is written such that it is differentiable by Zygote 0.5.3.\n\n\n\n\n\n","category":"method"},{"location":"Likelihood.html#Prior.jl","page":"Likelihood","title":"Prior.jl","text":"","category":"section"},{"location":"Likelihood.html","page":"Likelihood","title":"Likelihood","text":"Modules = [MCPhylo]\r\nPages   = [\"Prior.jl\"]\r\nFilter = ","category":"page"},{"location":"Likelihood.html#Main.MCPhylo.BirthDeath","page":"Likelihood","title":"Main.MCPhylo.BirthDeath","text":"Strict Molecular Clock - BirthDeath Implemented following Yang & Rannala 1997 doi.org/10.1093/oxfordjournals.molbev.a025811\n\n\n\n\n\n","category":"type"},{"location":"Likelihood.html#Main.MCPhylo.BirthDeathSimplified","page":"Likelihood","title":"Main.MCPhylo.BirthDeathSimplified","text":"Strict Molecular Clock - Simplified Birth Death Implemented folloing Yang & Rannala 1996 doi.org/10.1007/BF02338839\n\n\n\n\n\n","category":"type"},{"location":"Parser.html#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Functions found in all files of Parser folder, ordered according to file of origin.","category":"page"},{"location":"Parser.html#ParseCSV.jl","page":"Parser","title":"ParseCSV.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"Parser/ParseCSV.jl\"]\r\nFilter = ","category":"page"},{"location":"Parser.html#Main.MCPhylo.ParseCSV","page":"Parser","title":"Main.MCPhylo.ParseCSV","text":"ParseCSV(filename::String, header::Bool=true)\n\nThis function parses a CSV file containing input for the MCMC compuation. The file should follow the conventions used for MrBayes. For example:\n\nSwedish_0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,?,0,0,?,0,0\nWelsh_N_0,0,0,0,0,0,0,?,0,0,0,0,?,?,0,0,?,0,0,0,1,?,?,0\nSardinian_N_0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,?,0,0,0,0,0\n\nSet input for \"header\" to false if no header is present in the file.\n\n\n\n\n\n","category":"function"},{"location":"Parser.html#Main.MCPhylo.create_csvdf","page":"Parser","title":"Main.MCPhylo.create_csvdf","text":"function create_csvdf(filecontnt::Array{String}, separator::AbstractString=\",\")::DataFrame\n\nThis function parses a CSV file and returns its content as a DataFrame.\n\nNOTE: May later on be replaced by the respective DataFrames function.\n\n\n\n\n\n","category":"function"},{"location":"Parser.html#ParseNewick.jl","page":"Parser","title":"ParseNewick.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"ParseNewick.jl\"]\r\nFilter = ","category":"page"},{"location":"Parser.html#Main.MCPhylo.ParseNewick-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNewick","text":"ParseNewick(filename::String)::Array{AbstractNode, 1}\n\nThis function takes a filename as a String, and returns an array of trees(represented as Node objects). The file should solely consist of newick tree representations, separated by line. The function checks for proper newick formatting, and will return an error if the file is incorrectly formatted.\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#ParseNexus.jl","page":"Parser","title":"ParseNexus.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"ParseNexus.jl\"]\r\nFilter = ","category":"page"},{"location":"Parser.html#Main.MCPhylo.ParseNexus-Tuple{String}","page":"Parser","title":"Main.MCPhylo.ParseNexus","text":"ParseNexus(filename::String)\n\nThis function parses a NEXUS file which stores the input for the MCMC compuation. The file should follow the conventions used for MrBayes.\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#Main.MCPhylo.create_nexusdf-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.create_nexusdf","text":"create_nexusdf(filecontent::Array{String})::DataFrame\n\nThis function creates a DataFrame of the acutal data.\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#Main.MCPhylo.extract_meta_info-Tuple{Array{String,N} where N}","page":"Parser","title":"Main.MCPhylo.extract_meta_info","text":"extract_meta_info(content::Array{String})\n\nThis function extracts some meta information from the content of the nexus file. It \"eats-up\" the stack\n\n\n\n\n\n","category":"method"},{"location":"Parser.html#Parser.jl","page":"Parser","title":"Parser.jl","text":"","category":"section"},{"location":"Parser.html","page":"Parser","title":"Parser","text":"Modules = [MCPhylo]\r\nPages   = [\"Parser.jl\"]\r\nFilter = ","category":"page"},{"location":"samplers.html#samplers","page":"Samplers","title":"samplers","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Functions found in all files of samplers folder, ordered according to file of origin.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Pages = [\"samplers.md\"]","category":"page"},{"location":"samplers.html#abc.jl","page":"Samplers","title":"abc.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.ABC","category":"page"},{"location":"samplers.html#Main.MCPhylo.ABC","page":"Samplers","title":"Main.MCPhylo.ABC","text":"          ABC(params::ElementOrVector{Symbol},\n\n          scale::ElementOrVector{T}, summary::Function,\n\n          epsilon::Real; kernel::KernelDensityType=SymUniform,\n\n          dist::Function=(Tsim, Tobs) -> sqrt(sum(abs2, Tsim - Tobs)),\n\n          proposal::SymDistributionType=Normal, maxdraw::Integer=1,\n\n          nsim::Integer=1, decay::Real=1.0, randeps::Bool=false,\n\n          args...) where {T<:Real}\n\nConstruct a Sampler object for ABC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained. Returns a Sampler{ABCTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler.  Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"scale : scaling value or vector of the same length as the combined elements of nodes params for the proposal distribution.  Values are relative to the unconstrained parameter space, where candidate draws are generated.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"summary : function that takes a vector of observed or simulated data and returns a summary statistic or vector of statistics.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"epsilon : target tolerance for determining how similar observed and simulated data summary statistics need to be in order to accept a candidate draw.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"kernel : weighting kernel density of type Biweight, Cosine, Epanechnikov, Normal, SymTriangularDist, SymUniform, or Triweight to use in measuring similarity between observed and simulated data summary statistics.  Specified epsilon determines the standard deviation of Normal kernels and widths of the others.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"dist : positive function for the kernel density to compute distance between vectors of observed (Tobs) and simulated (Tsim) data summary statistics (default: Euclidean distance).","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"proposal : symmetric distribution of type Biweight, Cosine, Epanechnikov, Normal, SymTriangularDist, SymUniform, or Triweight to be centered around current parameter values and used to generate proposal draws.  Specified scale determines the standard deviations of Normal proposals and widths of the others.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"maxdraw : maximum number of unaccepted candidates to draw in each call of the sampler.  Draws are generated until one is accepted or the maximum is reached.  Larger values increase acceptance rates at the expense of longer runtimes.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"nsim : number of data sets to simulate in deciding whether to accept a candidate draw.  Larger values lead to closer approximations of the target distribution at the expense of longer runtimes.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"decay : if 0 < decay <= 1, the rate at which internal tolerances are monotonically decreased from the initial distance between observed and simulated summary statistics toward the maximum of each subsequent distance and epsilon; if decay = 0, internal tolerances are fixed at epsilon.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"randeps : whether to perturb internal tolerances by random exponential variates.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"args... : additional keyword arguments to be passed to the dist function.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#amm.jl","page":"Samplers","title":"amm.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.AMM","category":"page"},{"location":"samplers.html#Main.MCPhylo.AMM","page":"Samplers","title":"Main.MCPhylo.AMM","text":"AMM(params::ElementOrVector{Symbol}, Sigma::Matrix{T};\n    adapt::Symbol=:all, args...) where {T<:Real}\n\nConstruct a Sampler object for AMM sampling. Parameters are assumed to be  continuous, but may be constrained or unconstrained. Returns a Sampler{AMMTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-2","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params : stochastic node(s) to be updated with the sampler.  Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Sigma : covariance matrix for the non-adaptive multivariate normal proposal distribution.  The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"adapt : type of adaptation phase.  Options are\n:all : adapt proposal during all iterations.\n:burnin : adapt proposal during burn-in iterations.\n:none : no adaptation (multivariate Metropolis sampling with fixed proposal).","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"args... : additional keyword arguments to be passed to the AMMVariate constructor.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#amwg.jl","page":"Samplers","title":"amwg.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.AMWG","category":"page"},{"location":"samplers.html#Main.MCPhylo.AMWG","page":"Samplers","title":"Main.MCPhylo.AMWG","text":"AMWG(params::ElementOrVector{Symbol},\n\nsigma::ElementOrVector{T};\n\nadapt::Symbol=:all,\n\nargs...) where {T<:Real}\n\nConstruct a Sampler object for AMWG sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained. Returns a Sampler{ABCTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-3","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params:  stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"sigma: scaling value or vector of the same length as the combined elements of nodes ","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params, defining initial standard deviations for univariate normal proposal distributions. Standard deviations are relative to the unconstrained parameter space, where candidate draws are generated.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"adapt : type of adaptation phase.  Options are\n:all : adapt proposal during all iterations.\n:burnin : adapt proposal during burn-in iterations.\n:none : no adaptation (Metropolis-within-Gibbs sampling with fixed proposal).","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"args...: additional keyword arguments to be passed to the AMWGVariate constructor.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bhmc.jl","page":"Samplers","title":"bhmc.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BHMC","category":"page"},{"location":"samplers.html#Main.MCPhylo.BHMC","page":"Samplers","title":"Main.MCPhylo.BHMC","text":"BHMC(params::ElementOrVector{Symbol}, traveltime::Real)\n\nConstruct a Sampler object for BHMC sampling. Parameters are assumed to   have binary numerical values (0 or 1).\n\nReturns a Sampler{BHMCTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-4","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"traveltime: length of time over which particle paths are simulated. It is recommended that supplied values be of the form (n + frac12) pi, where optimal choices of n in mathbbZ^+ are expected to grow with the parameter space dimensionality. ","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bia.jl","page":"Samplers","title":"bia.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BIA","category":"page"},{"location":"samplers.html#Main.MCPhylo.BIA","page":"Samplers","title":"Main.MCPhylo.BIA","text":"BIA(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for BIA sampling. Parameters are assumed to have    binary numerical values (0 or 1).\n\nReturns a Sampler{BIATune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-5","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"args...: additional keyword arguments to be passed to the BIAVariate constructor.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bmc3.jl","page":"Samplers","title":"bmc3.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BMC3","category":"page"},{"location":"samplers.html#Main.MCPhylo.BMC3","page":"Samplers","title":"Main.MCPhylo.BMC3","text":"BMC3(params::ElementOrVector{Symbol}; k::F=1) where {F<:BMC3Form}\n\nConstruct a Sampler object for BMC3 sampling. Parameters are assumed to have binary numerical values (0 or 1).\n\nReturns a Sampler{BMC3Tune{typeof(k)}} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-6","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"k: number of parameters or vector of parameter indices to select at random for simultaneous updating in each call of the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#bmg.jl","page":"Samplers","title":"bmg.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.BMG","category":"page"},{"location":"samplers.html#Main.MCPhylo.BMG","page":"Samplers","title":"Main.MCPhylo.BMG","text":"BMG(params::ElementOrVector{Symbol}; k::F=1) where {F<:BMGForm}\n\nConstruct a Sampler object for BMG sampling. Parameters are assumed to have  binary numerical values (0 or 1).\n\nReturns a Sampler{BMGTune{typeof(k)}} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-7","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"k:  number of parameters or vector of parameter indices to select at random for simultaneous updating in each call of the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#dgs.jl","page":"Samplers","title":"dgs.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.DGS","category":"page"},{"location":"samplers.html#Main.MCPhylo.DGS","page":"Samplers","title":"Main.MCPhylo.DGS","text":"DGS(params::ElementOrVector{Symbol})\n\nConstruct a Sampler object for which DGS sampling is to be applied separately to each of the supplied parameters. Parameters are assumed to have discrete univariate distributions with finite supports.\n\nReturns a Sampler{DSTune{Function}} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-8","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#hmc.jl","page":"Samplers","title":"hmc.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.HMC","category":"page"},{"location":"samplers.html#Main.MCPhylo.HMC","page":"Samplers","title":"Main.MCPhylo.HMC","text":"HMC(params::ElementOrVector{Symbol}, epsilon::Real, L::Integer; args...)\n\nConstruct a Sampler object for HMC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{HMCTune} type object.\n\n\n\n\n\nHMC(params::ElementOrVector{Symbol}, epsilon::Real, L::Integer, Sigma::Matrix{T}; args...)\n\nConstruct a Sampler object for HMC sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{HMCTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-9","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"epsilon: step size.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"L: number of steps to take in the Leapfrog algorithm.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Sigma: covariance matrix for the multivariate normal proposal distribution. The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated. If omitted, the identity matrix is assumed.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"dtype : differentiation for gradient calculations. Options are\n:central : central differencing\n:forward : forward differencing.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#mala.jl","page":"Samplers","title":"mala.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.MALA","category":"page"},{"location":"samplers.html#Main.MCPhylo.MALA","page":"Samplers","title":"Main.MCPhylo.MALA","text":"MALA(params::ElementOrVector{Symbol}, epsilon::Real; args...)\n\nConstruct a Sampler object for MALA sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{MALATune}` type object.\n\n\n\n\n\nMALA(params::ElementOrVector{Symbol}, epsilon::Real, Sigma::Matrix{T}; args...)\n\nConstruct a Sampler object for MALA sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{MALATune}` type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-10","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"epsilon: factor by which the drift and covariance matrix of the proposal distribution are scaled.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Sigma: covariance matrix for the multivariate normal proposal distribution. The covariance matrix is relative to the unconstrained parameter space, where candidate draws are generated. If omitted, the identity matrix is assumed.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"dtype : differentiation for gradient calculations. Options are\n:central : central differencing\n:forward : forward differencing.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#miss.jl","page":"Samplers","title":"miss.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.MISS","category":"page"},{"location":"samplers.html#Main.MCPhylo.MISS","page":"Samplers","title":"Main.MCPhylo.MISS","text":"MISS(params::ElementOrVector{Symbol})\n\nConstruct a Sampler object to sampling missing output values. The constructor should only be used to sample stochastic nodes upon which no other stochastic node depends. So-called output nodes can be identified with the keys() function. Moreover, when the MISS constructor is included in a vector of Sampler objects to define a sampling scheme, it should be positioned at the beginning of the vector. This ensures that missing output values are updated before any other samplers are executed.\n\nReturns a Sampler{Dict{Symbol, MISSTune}} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-11","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) that contain missing values (NaN) to be updated with the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#nuts.jl","page":"Samplers","title":"nuts.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.NUTS","category":"page"},{"location":"samplers.html#Main.MCPhylo.NUTS","page":"Samplers","title":"Main.MCPhylo.NUTS","text":"NUTS(params::ElementOrVector{Symbol}; dtype::Symbol=:forward, args...)\n\nConstruct a Sampler object for NUTS sampling, with the algorithms step size parameter adaptively tuned during burn-in iterations. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{NUTSTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-12","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"dtype : differentiation for gradient calculations. Options are\n:central : central differencing\n:forward : forward differencing.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"args...: additional keyword arguments to be passed to the NUTSVariate constructor.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#rwm.jl","page":"Samplers","title":"rwm.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.RWM(::Main.MCPhylo.ElementOrVector{Symbol}, ::Main.MCPhylo.ElementOrVector{T}; args...) where {T<:Real}","category":"page"},{"location":"samplers.html#Main.MCPhylo.RWM-Union{Tuple{T}, Tuple{Union{Array{Symbol,1}, Symbol},Union{Array{T,1}, T}}} where T<:Real","page":"Samplers","title":"Main.MCPhylo.RWM","text":"RWM(params::ElementOrVector{Symbol},\n              scale::ElementOrVector{T}; args...) where {T<:Real})\n\nConstruct a Sampler object for RWM sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{RWMTune} type object.\n\n\n\n\n\n","category":"method"},{"location":"samplers.html#Arguments-13","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler. Constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"scale: scaling value or vector of the same length as the combined elements of nodes params for the proposal distribution. Values are relative to the unconstrained parameter space, where candidate draws are generated.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"args...: additional keyword arguments to be passed to the RWMVariate constructor.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#slice.jl","page":"Samplers","title":"slice.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.Slice","category":"page"},{"location":"samplers.html#Main.MCPhylo.Slice","page":"Samplers","title":"Main.MCPhylo.Slice","text":"Slice(params::ElementOrVector{Symbol},                 width::ElementOrVector{T},                 ::Type{F}=Multivariate;                 transform::Bool=false) where {T<:Real, F<:SliceForm}\n\nConstruct a Sampler object for Slice sampling. Parameters are assumed to be continuous, but may be constrained or unconstrained.\n\nReturns a Sampler{SliceTune{Univariate}} or Sampler{SliceTune{Multivariate}} type object if sampling univariately or multivariately, respectively.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-14","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"width: scaling value or vector of the same length as the combined elements of nodes params, defining initial widths of a hyperrectangle from which to simulate values.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"F : sampler type. Options are\n:Univariate : sequential univariate sampling of parameters.\n:Multivariate : joint multivariate sampling.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"transform: whether to sample parameters on the link-transformed scale (unconstrained parameter space). If true, then constrained parameters are mapped to unconstrained space according to transformations defined by the Stochastic unlist() function, and width is interpreted as being relative to the unconstrained parameter space. Otherwise, sampling is relative to the untransformed space.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"samplers.html#slicesimplex.jl","page":"Samplers","title":"slicesimplex.jl","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Main.MCPhylo.SliceSimplex","category":"page"},{"location":"samplers.html#Main.MCPhylo.SliceSimplex","page":"Samplers","title":"Main.MCPhylo.SliceSimplex","text":"SliceSimplex(params::ElementOrVector{Symbol}; args...)\n\nConstruct a Sampler object for which SliceSimplex sampling is to be applied separately to each of the supplied parameters. Parameters are assumed to be continuous and constrained to a simplex.\n\nReturns a Sampler{SliceSimplexTune} type object.\n\n\n\n\n\n","category":"function"},{"location":"samplers.html#Arguments-15","page":"Samplers","title":"Arguments","text":"","category":"section"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"params: stochastic node(s) to be updated with the sampler.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"args...: additional keyword arguments to be passed to the SliceSimplexVariate constructor.","category":"page"},{"location":"samplers.html","page":"Samplers","title":"Samplers","text":"Back to top.","category":"page"},{"location":"Substitution.html#Substitution","page":"Substitution","title":"Substitution","text":"","category":"section"},{"location":"Substitution.html","page":"Substitution","title":"Substitution","text":"Functions found in all files of Parser folder, ordered according to file of origin.","category":"page"},{"location":"Substitution.html#SubstitutionMat.jl","page":"Substitution","title":"SubstitutionMat.jl","text":"","category":"section"},{"location":"Substitution.html","page":"Substitution","title":"Substitution","text":"Modules = [MCPhylo]\r\nPages   = [\"Substitution/SubstitutionMat.jl\"]\r\nFilter = ","category":"page"}]
}
