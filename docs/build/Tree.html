<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tree Functionality · MCPhylo</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MCPhylo</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="intro.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="Tree.html">Tree Functionality</a><ul class="internal"><li><a class="tocitem" href="#Converter.jl"><span>Converter.jl</span></a></li><li><a class="tocitem" href="#Node_Type.jl"><span>Node_Type.jl</span></a></li><li><a class="tocitem" href="#Tree_Basics.jl"><span>Tree_Basics.jl</span></a></li><li><a class="tocitem" href="#Tree_Clustering.jl"><span>Tree_Clustering.jl</span></a></li><li><a class="tocitem" href="#Tree_Consensus.jl"><span>Tree_Consensus.jl</span></a></li><li><a class="tocitem" href="#Tree_Distance.jl"><span>Tree_Distance.jl</span></a></li><li><a class="tocitem" href="#Tree_Ladderizing.jl"><span>Tree_Ladderizing.jl</span></a></li><li><a class="tocitem" href="#Tree_Legacy.jl"><span>Tree_Legacy.jl</span></a></li><li><a class="tocitem" href="#Tree_moves.jl"><span>Tree_moves.jl</span></a></li><li><a class="tocitem" href="#Tree_Pruning.jl"><span>Tree_Pruning.jl</span></a></li><li><a class="tocitem" href="#Tree_Search.jl"><span>Tree_Search.jl</span></a></li><li><a class="tocitem" href="#Tree_Traversal.jl"><span>Tree_Traversal.jl</span></a></li></ul></li><li><a class="tocitem" href="Likelihood.html">Likelihood</a></li><li><a class="tocitem" href="Parser.html">Parser</a></li><li><a class="tocitem" href="distributions.html">Distributions</a></li><li><a class="tocitem" href="model.html">Model</a></li><li><a class="tocitem" href="output.html">Output</a></li><li><a class="tocitem" href="Sampler.html">Sampler</a></li><li><a class="tocitem" href="samplers.html">Samplers</a></li><li><a class="tocitem" href="Substitution.html">Substitution</a></li><li><a class="tocitem" href="Utils.html">Utils</a></li><li><a class="tocitem" href="Links.html">Links</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Tree.html">Tree Functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Tree.html">Tree Functionality</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/erathorn/Julia_Tree/blob/master/docs/src/Tree.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tree-Functionality"><a class="docs-heading-anchor" href="#Tree-Functionality">Tree Functionality</a><a id="Tree-Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Functionality" title="Permalink"></a></h1><p>Functions found in all files of Tree folder, ordered according to file of origin.</p><h2 id="Converter.jl"><a class="docs-heading-anchor" href="#Converter.jl">Converter.jl</a><a id="Converter.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Converter.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.from_df" href="#Main.MCPhylo.from_df"><code>Main.MCPhylo.from_df</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">from_df(df::DataFrame)::Node</code></pre><p>This function takes a DataFrame and turns it into a tree. It assumes a rooted binary tree is stored in the matrix. No checks are performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Converter.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.newick-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.newick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newick(node::Node)::String</code></pre><p>Creates a newick represnetation of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Converter.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_covariance" href="#Main.MCPhylo.to_covariance"><code>Main.MCPhylo.to_covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_covariance(tree::N, blv::Array{T})::Array{T,2} where {N&lt;:GeneralNode,T&lt;: Real}</code></pre><p>Calcualte the variance-covariance matrix from <code>tree</code>. An entry (i,j) of the matrix is defined as the length of the path connecting the latest common ancestor of i and j with the root of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Converter.jl#L164-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_covariance_ultra" href="#Main.MCPhylo.to_covariance_ultra"><code>Main.MCPhylo.to_covariance_ultra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_covariance_ultra(tree::Node)::Array{T,2} where T&lt;: Real</code></pre><p>Get the covariance matrix of the ultrametric version of <code>tree</code> with height 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Converter.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_df" href="#Main.MCPhylo.to_df"><code>Main.MCPhylo.to_df</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_df(root::Node)::DataFrame</code></pre><p>This function returns a matrix representation of the tree structure. The matirx is returned as a DataFrame so that the names of the columns are the names of the tips in the tree. The entry <code>df[i,j]</code> is the length of the edge connecting node <code>i</code> with node <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Converter.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.to_distance_matrix" href="#Main.MCPhylo.to_distance_matrix"><code>Main.MCPhylo.to_distance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_distance_matrix(tree::T)::Array{Float64,2} where T &lt;:GeneralNode</code></pre><p>Calculate the distance matrix over the set of leaves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Converter.jl#L143-L147">source</a></section></article><h2 id="Node_Type.jl"><a class="docs-heading-anchor" href="#Node_Type.jl">Node_Type.jl</a><a id="Node_Type.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Node_Type.jl" title="Permalink"></a></h2><h2 id="Tree_Basics.jl"><a class="docs-heading-anchor" href="#Tree_Basics.jl">Tree_Basics.jl</a><a id="Tree_Basics.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Basics.jl" title="Permalink"></a></h2><p>This file is a bit larger, and so will be broken into (hopefully coherent) subgroups, listed here:</p><p><a href="Tree.html#Tree-Editing">Tree Editing</a></p><p><a href="Tree.html#Return-Functions">Return Functions</a></p><p><a href="Tree.html#Metavariable-Functions">Metavariable Functions</a></p><p><a href="Tree.html#Variable-Functions">Variable Functions</a></p><h3 id="Tree-Editing"><a class="docs-heading-anchor" href="#Tree-Editing">Tree Editing</a><a id="Tree-Editing-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Editing" title="Permalink"></a></h3><p>These functions edit the makeup of an existing tree.</p><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.add_child!" href="#Main.MCPhylo.add_child!"><code>Main.MCPhylo.add_child!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_child!(mother_node::Node, child::Node, child_position::Union{Int64, Missing}=missing)</code></pre><p>This function adds a child to the mother node. The arity of the mother node is increased by <code>1</code> and the root status of the child is set to <code>False</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.delete_node!" href="#Main.MCPhylo.delete_node!"><code>Main.MCPhylo.delete_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete_node!(node::Node)::Nothing</code></pre><p>This functions deletes node from a tree and assigns all its children to its mother node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.insert_node!" href="#Main.MCPhylo.insert_node!"><code>Main.MCPhylo.insert_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_node!(mother::Node, children::Vector{T})::T where T&lt;:AbstractNode</code></pre><p>This function inserts a node into a tree after a mother node and gains a subset of the mother&#39;s children as its children. Returns the inserted node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.remove_child!" href="#Main.MCPhylo.remove_child!"><code>Main.MCPhylo.remove_child!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_child!(mother_node::Node, left::Bool)::Node</code></pre><p>This function removes a child from the list of nodes which are daughters of this node. The removed node is returned. An input of &quot;True&quot; removes the left child, while &quot;False&quot; removes the right child.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L29-L35">source</a></section><section><div><pre><code class="language-none">remove_child!(mother_node::Node, child::Node)::Node</code></pre><p>This function removes a child from the list of nodes which are daughters of this node. The removed node is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.create_tree_from_leaves" href="#Main.MCPhylo.create_tree_from_leaves"><code>Main.MCPhylo.create_tree_from_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_tree_from_leaves(leaf_nodes::Vector{T})::Node</code></pre><p>This function creates a  random binary tree from a list of leaf nodes. The root node as access point for the tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L168-L173">source</a></section></article><h3 id="Return-Functions"><a class="docs-heading-anchor" href="#Return-Functions">Return Functions</a><a id="Return-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Functions" title="Permalink"></a></h3><p>These functions return the values of a given variable of a tree.</p><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_mother" href="#Main.MCPhylo.get_mother"><code>Main.MCPhylo.get_mother</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function get_mother(node::T)::T  where T&lt;:GeneralNode</code></pre><p>This function gets the mother of <code>node</code>. It does so by looking for the respective binary representation of the mother node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L404-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_sister" href="#Main.MCPhylo.get_sister"><code>Main.MCPhylo.get_sister</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_sister(node::T)::T  where T&lt;:GeneralNode</code></pre><p>This function gets the sister of <code>node</code>. It does so by looking for the respective binary representation of the sister.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L393-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.node_height" href="#Main.MCPhylo.node_height"><code>Main.MCPhylo.node_height</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">node_height(root::T, mv::Float64)::Float64  where T&lt;:GeneralNode</code></pre><p>Calculate the height of a node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.random_node" href="#Main.MCPhylo.random_node"><code>Main.MCPhylo.random_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function random_node(root::T)::T  where T&lt;:GeneralNode</code></pre><p>This function returns a random node from the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L447-L451">source</a></section></article><h3 id="Metavariable-Functions"><a class="docs-heading-anchor" href="#Metavariable-Functions">Metavariable Functions</a><a id="Metavariable-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Metavariable-Functions" title="Permalink"></a></h3><p>These functions calculate metavariables for a given tree.</p><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.tree_length-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.tree_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree_length(root::T)::Float64  where T&lt;:GeneralNode</code></pre><p>This function calculates the tree length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L281-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.tree_height" href="#Main.MCPhylo.tree_height"><code>Main.MCPhylo.tree_height</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tree_height(root::T)::Float64  where T&lt;:GeneralNode</code></pre><p>This function calculates the tree height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L310-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector" href="#Main.MCPhylo.get_branchlength_vector"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(root::N)::Vector{T}  where {N &lt;:GeneralNode, T&lt;:Real}</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L461-L465">source</a></section><section><div><pre><code class="language-none">get_branchlength_vector(t::TreeStochastic)</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L474-L478">source</a></section><section><div><pre><code class="language-none">get_branchlength_vector(root::N, out_vec::Vector{T}) where {N&lt;:GeneralNode, T&lt;:Real}</code></pre><p>Do post order traversal to retrieve a vector of branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L483-L487">source</a></section><section><div><pre><code class="language-julia">get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}</code></pre><p>Return a vector of branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Legacy.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_sum_seperate_length!" href="#Main.MCPhylo.get_sum_seperate_length!"><code>Main.MCPhylo.get_sum_seperate_length!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_sum_seperate_length!(root::T)::Vector{Float64}  where T&lt;:GeneralNode</code></pre><p>This function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L540-L545">source</a></section><section><div><pre><code class="language-none">get_sum_seperate_length!(post_order::Vector{T})::Vector{Float64}  where T&lt;:GeneralNode</code></pre><p>This function gets the sum of the branch lengths of the internal branches and the branches leading to the leave nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L551-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.check_binary" href="#Main.MCPhylo.check_binary"><code>Main.MCPhylo.check_binary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">check_binary(root::Node)::Bool</code></pre><p>checks to see if given tree is binary; returns true if properly formatted and false otherwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L639-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.path_length" href="#Main.MCPhylo.path_length"><code>Main.MCPhylo.path_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">path_length(ancestor::T, descendant::T)::Float64  where T&lt;:GeneralNode</code></pre><p>Note: The function assumes there is an ancestral relationship between the two nodes.</p><p>This function calculates the length of the path separating the ancestor from the offspring node. The function follows the path specified through the binary description of the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L373-L381">source</a></section></article><h3 id="Variable-Functions"><a class="docs-heading-anchor" href="#Variable-Functions">Variable Functions</a><a id="Variable-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Functions" title="Permalink"></a></h3><p>These Functions calculate/edit variables for a given tree.</p><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.force_ultrametric!" href="#Main.MCPhylo.force_ultrametric!"><code>Main.MCPhylo.force_ultrametric!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">force_ultrametric!(root::T) where T&lt;:GeneralNode</code></pre><p>Force an ultrametric version of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.number_nodes!" href="#Main.MCPhylo.number_nodes!"><code>Main.MCPhylo.number_nodes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">number_nodes!(root::T)::Nothing  where T&lt;:GeneralNode</code></pre><p>This function assigns a unique, sequential number to each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L435-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_branchlength_vector!" href="#Main.MCPhylo.set_branchlength_vector!"><code>Main.MCPhylo.set_branchlength_vector!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_branchlength_vector!(t::TreeStochastic, blenvec::Array{T}) where T &lt;: Real</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L499-L503">source</a></section><section><div><pre><code class="language-none">set_branchlength_vector!(t::TreeStochastic, blenvec::ArrayStochastic)</code></pre><p>Get the vector of branch lengths of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L508-L512">source</a></section><section><div><pre><code class="language-none">set_branchlength_vector!(root::N, blenvec::Array{T}) where {N&lt;:GeneralNode, T&lt;:Real}</code></pre><p>This function sets the branch lengths of a tree to the values specified in blenvec.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L522-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.set_binary!" href="#Main.MCPhylo.set_binary!"><code>Main.MCPhylo.set_binary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_binary!(root::Node)</code></pre><p>Assign a binary representation to each node, which specifies the path from the root to this node via the binary representation of the node. A left turn is a 1 in binary and a right turn a 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Basics.jl#L414-L420">source</a></section></article><h2 id="Tree_Clustering.jl"><a class="docs-heading-anchor" href="#Tree_Clustering.jl">Tree_Clustering.jl</a><a id="Tree_Clustering.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Clustering.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.neighbor_joining" href="#Main.MCPhylo.neighbor_joining"><code>Main.MCPhylo.neighbor_joining</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">neighbor_joining(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Clustering.jl#L116-L122">source</a></section><section><div><pre><code class="language-none">neighbor_joining(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using neighbor-joining based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Clustering.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.upgma" href="#Main.MCPhylo.upgma"><code>Main.MCPhylo.upgma</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">upgma(dm::Array{Float64,2}, Array{String,1})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix and an array of leaf names. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Clustering.jl#L1-L7">source</a></section><section><div><pre><code class="language-none">upgma(dm::Array{Float64,2})</code></pre><p>This function returns a phylogenetic tree by using UPGMA based on a given distance matrix. Creates an array of nodes to be used as leaves. Returns a node of the resulting tree, from which it can be traversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Clustering.jl#L22-L28">source</a></section></article><h2 id="Tree_Consensus.jl"><a class="docs-heading-anchor" href="#Tree_Consensus.jl">Tree_Consensus.jl</a><a id="Tree_Consensus.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Consensus.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.find_common_clusters-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.find_common_clusters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_common_clusters(ref_tree, tree:T)
    ::Dict{Int64, Tuple{Bool, Union{Float64, Missing}}}</code></pre><p>Use Day&#39;s algorithm to create a dictionary, that tells us for each node of the second input tree, if its corresponding cluster is a common cluster of the trees</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Consensus.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.majority_consensus_tree-Union{Tuple{T}, Tuple{Array{T,1}}, Tuple{Array{T,1},Float64}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.majority_consensus_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">majority_consensus_tree(trees::Vector{T}, percentage::Float64=0.5)::T where T&lt;:AbstractNode</code></pre><p>Construct the majority rule consensus tree from a set of trees. By default includes cluster that occur in over 50% of the trees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Consensus.jl#L422-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.max_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.max_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T&lt;:AbstractNode</code></pre><p>Recursive helper function to find the highest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Consensus.jl#L340-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.merge_trees!-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.merge_trees!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge_trees!(ref_tree::T, tree::T)::Tuple{T, Vector{T}} where T&lt;:AbstractNode</code></pre><p>Merge two compatible trees, i.e. inserts all cluster of the first tree, which aren&#39;t already in the second tree, into the secon tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Consensus.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.min_leaf_rank-Union{Tuple{T}, Tuple{Dict{String,Int64},T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.min_leaf_rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">min_leaf_rank(leaf_ranks::Dict{String, Int64}, node::T)
    ::Int64 where T &lt;: AbstractNode</code></pre><p>Recursive helper function to find the lowest ranked leaf descendant of a node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Consensus.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.one_way_compatible-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.one_way_compatible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one_way_compatible(ref_tree::T, tree::T)::T where T&lt;:AbstractNode</code></pre><p>Takes two trees and returns a copy of the first one, where all the clusters that are not compatible with the second tree are removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Consensus.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.order_tree!-Union{Tuple{T}, Tuple{T,Dict{T,Int64}}, Tuple{T,Dict{T,Int64},Any}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.order_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order_tree!(root::T, cluster_start_indeces::Dict{T, Int64}, leaves=Vector{T}())
    ::Vector{T} where T&lt;:AbstractNode</code></pre><p>Helper function to order a tree based on cluster indeces and return the leaves of the ordered tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Consensus.jl#L297-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.x_left-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.x_left</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x_left(node::T)::Tuple{T,Vector{T}} where T&lt;:AbstractNode</code></pre><p>Helper function to find ancestor of a leaf that has said leaf as leftmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Consensus.jl#L363-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.x_right-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.x_right</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x_right(node::T)::Tuple{T,Vector{T}} where T&lt;:AbstractNode</code></pre><p>Helper function to find ancestor of a leaf that has said leaf as rightmost descendant. Also returns the path from the leaf to the mother of that node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Consensus.jl#L387-L392">source</a></section></article><h2 id="Tree_Distance.jl"><a class="docs-heading-anchor" href="#Tree_Distance.jl">Tree_Distance.jl</a><a id="Tree_Distance.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Distance.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.BHV_bounds-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.BHV_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BHV_bounds(tree1::T, tree2::T)::Tuple{Float64, Float64} where T &lt;:GeneralNode</code></pre><p>This function calculates the lower and upper bounds of the geodesic in the Billera-Holmes-Vogtman space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Distance.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.RF-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.RF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RF(tree1::T, tree2::T)::Int64 where T &lt;:GeneralNode</code></pre><p>Calculate the Robinson-Foulds distance between the two trees. In its current form the function assumes the trees have identical leave sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Distance.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_bipartitions-Union{Tuple{T}, Tuple{T}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_bipartitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_bipartitions(tree::T)::Vector{Tuple} where T &lt;:GeneralNode</code></pre><p>Get a vector of all bipartions of <code>tree</code>. The resulting vector contains Tuples of sets representing the bipartions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Distance.jl#L15-L20">source</a></section></article><h2 id="Tree_Ladderizing.jl"><a class="docs-heading-anchor" href="#Tree_Ladderizing.jl">Tree_Ladderizing.jl</a><a id="Tree_Ladderizing.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Ladderizing.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.ladderize_tree!-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.ladderize_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ladderize_tree!(root::T, ascending::Bool=true)::Nothing where T&lt;:AbstractNode)</code></pre><p>This function ladderizes a tree inplace, i.e. sorts the nodes on all levels by the count of their descendants</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Ladderizing.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode" href="#Main.MCPhylo.ladderize_tree-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Main.MCPhylo.AbstractNode"><code>Main.MCPhylo.ladderize_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ladderize_tree(root::T, ascending::Bool=true)::T where T&lt;:AbstractNode)</code></pre><p>This function returns a ladderized copy of a tree, i.e. a copy with all the nodes on all levels sorted by the count of their descendants</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Ladderizing.jl#L22-L27">source</a></section></article><h2 id="Tree_Legacy.jl"><a class="docs-heading-anchor" href="#Tree_Legacy.jl">Tree_Legacy.jl</a><a id="Tree_Legacy.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Legacy.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode" href="#Main.MCPhylo.get_branchlength_vector-Union{Tuple{T}, Tuple{Array{T,1}}} where T&lt;:Main.MCPhylo.GeneralNode"><code>Main.MCPhylo.get_branchlength_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_branchlength_vector(post_order::Vector{Node})::Vector{Float64}</code></pre><p>Return a vector of branch lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Legacy.jl#L3-L7">source</a></section></article><h2 id="Tree_moves.jl"><a class="docs-heading-anchor" href="#Tree_moves.jl">Tree_moves.jl</a><a id="Tree_moves.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_moves.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI!" href="#Main.MCPhylo.NNI!"><code>Main.MCPhylo.NNI!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">NNI(root::T, target::T, lor::Bool)::Int64   where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The parameter <code>target</code> specifies the node which performs the interchange move using the left or right child of the target node. If the left child should be used <code>lor=true</code>. The function returns 1 if the move was successful and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L4-L12">source</a></section><section><div><pre><code class="language-none">NNI!(root::T, target::Int64)::Int64  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The target is identified by the number of the target node. The function returns 1 if the move was successful and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L34-L40">source</a></section><section><div><pre><code class="language-none">NNI!(root::T)::Int64  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code>. The target is identified by the number of the target node. The function returns 1 if the move was successful and 0 else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.NNI" href="#Main.MCPhylo.NNI"><code>Main.MCPhylo.NNI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">NNI(root::T)::T  where T&lt;:GeneralNode</code></pre><p>This function does a nearest neighbour interchange (NNI) move on the tree specified by <code>root</code> and returns a mutated copy while leaving the original tree intact.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.change_edge_length!" href="#Main.MCPhylo.change_edge_length!"><code>Main.MCPhylo.change_edge_length!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">change_edge_length!(root::T) where T &lt;:GeneralNode</code></pre><p>Pick a random node and increase or decrease its length randomly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.move!" href="#Main.MCPhylo.move!"><code>Main.MCPhylo.move!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move!(node1::Node, node2::Node, proportion::Float64)</code></pre><p>Change the incoming length of node1 and node2 while keeping their combined length constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L188-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.perform_spr" href="#Main.MCPhylo.perform_spr"><code>Main.MCPhylo.perform_spr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perform_spr(root::Node)</code></pre><p>performs SPR on binary tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L287-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.randomize!" href="#Main.MCPhylo.randomize!"><code>Main.MCPhylo.randomize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomize!(root::Node, num::Int64=100)::nothing</code></pre><p>This function randomizes the tree topology by performing a number of nearest neighbour interchange (NNI) moves. The number of NNI moves is specified in the parameter num.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.risky_SPR!" href="#Main.MCPhylo.risky_SPR!"><code>Main.MCPhylo.risky_SPR!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    risky_SPR!(root::Node)::AbstractNode
Performs SPR on tree in place. Takes reference to root of tree
Returns reference to root of altered tree. Does not check for correct formatting of tree.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.risky_SPR" href="#Main.MCPhylo.risky_SPR"><code>Main.MCPhylo.risky_SPR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    risky_SPR(root::Node)::AbstractNode
Performs SPR on tree in place. Takes reference to root of tree
Returns copy of root of altered tree. Does not check for correct formatting of tree.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.slide" href="#Main.MCPhylo.slide"><code>Main.MCPhylo.slide</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">slide(root::T)::T where T&lt;:GeneralNode</code></pre><p>This functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters. The new tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.slide!" href="#Main.MCPhylo.slide!"><code>Main.MCPhylo.slide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">slide!(root::T) where T&lt;:GeneralNode</code></pre><p>This functin performs a slide move on an intermediate node. The node is moved upwards or downwards on the path specified by its mother and one of its daughters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.swing!" href="#Main.MCPhylo.swing!"><code>Main.MCPhylo.swing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">swing!(root::T) where T&lt;:GeneralNode</code></pre><p>This function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.swing" href="#Main.MCPhylo.swing"><code>Main.MCPhylo.swing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">swing(root::T)::T where T&lt;:GeneralNode</code></pre><p>This function performs a swing node. A random non-leave node is selected and moved along the path specified by its two children. The new tree is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_moves.jl#L139-L144">source</a></section></article><h2 id="Tree_Pruning.jl"><a class="docs-heading-anchor" href="#Tree_Pruning.jl">Tree_Pruning.jl</a><a id="Tree_Pruning.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Pruning.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.prune_tree!" href="#Main.MCPhylo.prune_tree!"><code>Main.MCPhylo.prune_tree!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prune_tree!(root::T, node_names::Vector{String})::Nothing where T&lt;:AbstractNode</code></pre><p>In-place version of prune_tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Pruning.jl#L18-L22">source</a></section><section><div><pre><code class="language-none">prune_tree!(root::T, node_names::Vector{T})::Nothing where T&lt;:AbstractNode</code></pre><p>In-place version of prune_tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Pruning.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.prune_tree" href="#Main.MCPhylo.prune_tree"><code>Main.MCPhylo.prune_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prune_tree(root::T, node_names::Vector{String})::T where T&lt;:AbstractNode</code></pre><p>This function returns a copy of a tree with specific nodes including their descendants removed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Pruning.jl#L1-L6">source</a></section></article><h2 id="Tree_Search.jl"><a class="docs-heading-anchor" href="#Tree_Search.jl">Tree_Search.jl</a><a id="Tree_Search.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Search.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_binary" href="#Main.MCPhylo.find_binary"><code>Main.MCPhylo.find_binary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_binary(root::T, bin::String)::T where T&lt;:GeneralNode</code></pre><p>Find a node by its binary representation. The function assumes that the node is present in the tree.</p><p>Do not use this function if you are unsure wheter the node is in the tree at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Search.jl#L78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_num" href="#Main.MCPhylo.find_num"><code>Main.MCPhylo.find_num</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_num(root::T, num::Int64)  where T&lt;:GeneralNode</code></pre><p>Find a node by its number. The function assumes that the node is present in the tree.</p><p>Do not use this function if you are unsure wheter the node is in the tree at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Search.jl#L35-L42">source</a></section><section><div><pre><code class="language-none">find_num(root::T, num::Int64, rn::Vector{T})::Bool  where T&lt;:GeneralNode</code></pre><p>Do a post order traversal to find the node corresponding to the <code>num</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Search.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.find_root" href="#Main.MCPhylo.find_root"><code>Main.MCPhylo.find_root</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_root(node::Node)::Node</code></pre><p>Takes a node in a tree and finds the root of that tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Search.jl#L94-L98">source</a></section></article><h2 id="Tree_Traversal.jl"><a class="docs-heading-anchor" href="#Tree_Traversal.jl">Tree_Traversal.jl</a><a id="Tree_Traversal.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tree_Traversal.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.get_leaves" href="#Main.MCPhylo.get_leaves"><code>Main.MCPhylo.get_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">post_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a post order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the post order traversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Traversal.jl#L32-L38">source</a></section><section><div><pre><code class="language-none">post_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does post order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Traversal.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.level_order" href="#Main.MCPhylo.level_order"><code>Main.MCPhylo.level_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">level_order(node::T)::Array{T} where T&lt;:GeneralNode</code></pre><p>This function does level order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Traversal.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.level_traverse" href="#Main.MCPhylo.level_traverse"><code>Main.MCPhylo.level_traverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">level_traverse(node::T, level::Int64, stack::Array{T})::Bool where T &lt;:GeneralNode</code></pre><p>This function traverses a level of the tree specified through <code>node</code>. The level is specified via the <code>level</code> argument and the nodes visited are stored in the <code>stack</code>. This function is intended as the internal worker for the level_order function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Traversal.jl#L113-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.post_order" href="#Main.MCPhylo.post_order"><code>Main.MCPhylo.post_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">post_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a post order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the post order traversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Traversal.jl#L3-L9">source</a></section><section><div><pre><code class="language-none">post_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does post order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Traversal.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.MCPhylo.pre_order" href="#Main.MCPhylo.pre_order"><code>Main.MCPhylo.pre_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pre_order(root::T, traversal::Vector{T})::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function performs a pre order traversal through the tree. It is assumed that <code>root</code> is the root of the tree. Thus, if <code>root</code> is not the root, the subtree defined by the root <code>root</code> is used for the pre order traversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Traversal.jl#L68-L74">source</a></section><section><div><pre><code class="language-none">pre_order(root::T)::Vector{T} where T&lt;:GeneralNode</code></pre><p>This function does pre order traversal. Only the root node needs to be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/erathorn/Julia_Tree/blob/0d2aec300f67d86ddde53c3d6371f8727e3fd411/src/Tree/Tree_Traversal.jl#L86-L90">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="intro.html">« Introduction</a><a class="docs-footer-nextpage" href="Likelihood.html">Likelihood »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 10 December 2020 17:59">Thursday 10 December 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
